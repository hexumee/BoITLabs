![](https://github.com/hexumee/BoITLabs/blob/main/screenshots/lab3.png?raw=true)

Пусть у нас будет 11-битовое слово 10010010111. Вставим в него контрольные биты таким образом, чтобы номера их позиций представляли собой целые степени двойки (1, 2, 4, 8, 16…). Получим 15-разрядное слово 001000100010111 с 11 информационными и 4 контрольными битами. Первоначально контрольные биты устанавливаем равными нулю.

Теперь составим и заполним матрицу преобразования:
| 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14  | 15  |    |    |
|----|----|----|----|----|----|----|----|----|----|----|----|----|-----|-----|----|----|
| p1 | p2 | d1 | p3 | d2 | d3 | d4 | p4 | d5 | d6 | d7 | d8 | d9 | d10 | d11 |    |    |
| 0  | 0  | 1  | 0  | 0  | 0  | 1  | 0  | 0  | 0  | 1  | 0  | 1  | 1   | 1   |    |    |
| 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0   | 1   | p1 | 1  |
| 0  | 1  | 1  | 0  | 0  | 1  | 1  | 0  | 0  | 1  | 1  | 0  | 0  | 1   | 1   | p2 | 1  |
| 0  | 0  | 0  | 1  | 1  | 1  | 1  | 0  | 0  | 0  | 0  | 1  | 1  | 1   | 1   | p3 | 0  |
| 0  | 0  | 0  | 0  | 0  | 0  | 0  | 1  | 1  | 1  | 1  | 1  | 1  | 1   | 1   | p4 | 0  |

Для подсчета контрольных битов будем умножать соответствующие биты строки сообщения и строки матрицы, потом находим сумму произведений и берем это число по модулю 2. Например, для строки p1: p1=(1\*0+0\*0+1\*1+0\*0+1\*0+0\*0+1\*1+0\*0+1\*0+0\*0+1\*1+0\*0+1\*1+0\*1+1\*1) mod 2 = 1. Наконец, подставляем контрольные биты на свои места и получаем закодированное сообщение: 111000100010111.

Допустим, сообщение выше пришло с ошибкой: 111000101010111. 
| 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14  | 15  |    |    |
|----|----|----|----|----|----|----|----|----|----|----|----|----|-----|-----|----|----|
| p1 | p2 | d1 | p3 | d2 | d3 | d4 | p4 | d5 | d6 | d7 | d8 | d9 | d10 | d11 |    |    |
| 1  | 1  | 1  | 0  | 0  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 1   | 1   |    |    |
| 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0  | 1  | 0   | 1   | s1 | 1  |
| 0  | 1  | 1  | 0  | 0  | 1  | 1  | 0  | 0  | 1  | 1  | 0  | 0  | 1   | 1   | s2 | 0  |
| 0  | 0  | 0  | 1  | 1  | 1  | 1  | 0  | 0  | 0  | 0  | 1  | 1  | 1   | 1   | s3 | 0  |
| 0  | 0  | 0  | 0  | 0  | 0  | 0  | 1  | 1  | 1  | 1  | 1  | 1  | 1   | 1   | s4 | 1  |

Для подсчета синдрома снова воспользуемся перемножением строк. Чтобы получить номер ошибочной позиции, нужно двоичную запись синдрома (s4 -> s1) перевернуть и привести в десятичному виду. В нашем случае, синдром соответствует 1001 (в двоичной СС) или 9 (в десятичной СС), то есть нужно исправить 9-ый бит.

